import { Connection, Keypair, Transaction } from '@solana/web3.js';
import type { Cache } from 'cache-manager';
import { simulateRawTransaction, MessageToken } from '../core';
import base58 from 'bs58';

/**
 * Signs transaction previously generated by Octane after user's signature
 *
 * Context:
 * Octane provides swap API in two steps. First Octane endpoint creates a transaction without any signatures and
 * returns it to the client. Client signs the transaction, then submits to another Octane endpoint.
 * The second endpoint signs the transaction on behalf of Octane and sends it to the network. Since the transaction
 * was generated by Octane, we can trust it doesn't drain fee payer account.
 *
 * However, user can forge transaction between 1st and 2nd endpoint calls. Unless we can store it somewhere (and we don't
 * want Octane to have critical persistent state since it's designed to run on serverless platforms),
 * we need to either re-generate transaction within the 2nd endpoint and make sure it matches with the user-provided
 * transaction or find a way to verify user hasn't tampered with the transaction. The first approach isn't realistic
 * since the transaction generation depends on changing pool state and requires additional params in the 2nd endpoint.
 * The second approach, the one implemented here, can rely on signatures, generated with fee payer's secret key and payload,
 * which includes transaction message and some other data (to make it different from usual Solana signatures).
 *
 * Why not just generate the transaction with fee payer's signature already backed in? If Octane does that,
 * it enables an attack which allows to drain transaction fee funds: someone could request a transaction,
 * then make it invalid (for example, by withdrawing all of the tokens from the account), then submit original
 * transaction with an option to skip pre-flight checks. Transaction won't succeed, but the fee payer would be charged
 * for a transaction fee.
 *
 * @param connection      Connection to a Solana node
 * @param transaction     Transaction to sign
 * @param feePayer        Keypair for fee payer
 * @param messageTokenKey Type of generated transaction. For example, whirlpools.MESSAGE_TOKEN_KEY
 * @param messageToken    Token created, when instructions were generated by Octane.
 * @param cache           A cache to store duplicate transactions
 *
 * @return {signature: string} Transaction signature by fee payer
 */
export async function signGeneratedTransaction(
    connection: Connection,
    transaction: Transaction,
    feePayer: Keypair,
    messageTokenKey: string,
    messageToken: string,
    cache: Cache,
): Promise<{ signature: string }> {
    // Check that we actually produced this transaction previously
    if (!MessageToken.isValid(
        messageTokenKey, transaction.compileMessage(), messageToken, feePayer.publicKey
    )) {
        throw new Error('Message token isn\'t valid');
    }

    // Prevent multiple signature requests of the same transaction
    const key = `swap/sign/${messageToken}`;
    if (await cache.get(key)) throw new Error('Duplicate signature request');
    await cache.set(key, true);

    // Check that user signed  and Octane hasn't yet

    if (transaction.signatures.length < 2) { // user + fee payer
        throw new Error('Transaction should have at least 2 pubkeys as signers');
    }

    const hasFeePayerSignaturePlaceholder = (
        transaction.signatures[0].publicKey.equals(feePayer.publicKey)
        && transaction.signatures[0].signature === null
    );
    const hasAllOtherSignatures = transaction.signatures.slice(1).every(
        (pair) => pair.signature !== null
    );

    if (!hasFeePayerSignaturePlaceholder) {
        throw new Error('Fee payer\'s signature doesn\'t exist or already filled');
    }
    if (!hasAllOtherSignatures) {
        throw new Error('Missing user\'s signature');
    }

    transaction.partialSign(feePayer);

    // .serialize() verifies all signatures
    const serializedTransaction = transaction.serialize();

    await simulateRawTransaction(
        connection,
        serializedTransaction,
    );

    return { signature: base58.encode(transaction.signature!) };
}
